// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'weather_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$WeatherFailureTearOff {
  const _$WeatherFailureTearOff();

  NoConnection noConnection() {
    return const NoConnection();
  }

  InternalServerError internalServerError() {
    return const InternalServerError();
  }

  UserRequesrError userRequestError() {
    return const UserRequesrError();
  }

  JsonParsingError jsonParsingError() {
    return const JsonParsingError();
  }
}

/// @nodoc
const $WeatherFailure = _$WeatherFailureTearOff();

/// @nodoc
mixin _$WeatherFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noConnection,
    required TResult Function() internalServerError,
    required TResult Function() userRequestError,
    required TResult Function() jsonParsingError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noConnection,
    TResult Function()? internalServerError,
    TResult Function()? userRequestError,
    TResult Function()? jsonParsingError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoConnection value) noConnection,
    required TResult Function(InternalServerError value) internalServerError,
    required TResult Function(UserRequesrError value) userRequestError,
    required TResult Function(JsonParsingError value) jsonParsingError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoConnection value)? noConnection,
    TResult Function(InternalServerError value)? internalServerError,
    TResult Function(UserRequesrError value)? userRequestError,
    TResult Function(JsonParsingError value)? jsonParsingError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WeatherFailureCopyWith<$Res> {
  factory $WeatherFailureCopyWith(
          WeatherFailure value, $Res Function(WeatherFailure) then) =
      _$WeatherFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$WeatherFailureCopyWithImpl<$Res>
    implements $WeatherFailureCopyWith<$Res> {
  _$WeatherFailureCopyWithImpl(this._value, this._then);

  final WeatherFailure _value;
  // ignore: unused_field
  final $Res Function(WeatherFailure) _then;
}

/// @nodoc
abstract class $NoConnectionCopyWith<$Res> {
  factory $NoConnectionCopyWith(
          NoConnection value, $Res Function(NoConnection) then) =
      _$NoConnectionCopyWithImpl<$Res>;
}

/// @nodoc
class _$NoConnectionCopyWithImpl<$Res>
    extends _$WeatherFailureCopyWithImpl<$Res>
    implements $NoConnectionCopyWith<$Res> {
  _$NoConnectionCopyWithImpl(
      NoConnection _value, $Res Function(NoConnection) _then)
      : super(_value, (v) => _then(v as NoConnection));

  @override
  NoConnection get _value => super._value as NoConnection;
}

/// @nodoc

class _$NoConnection implements NoConnection {
  const _$NoConnection();

  @override
  String toString() {
    return 'WeatherFailure.noConnection()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is NoConnection);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noConnection,
    required TResult Function() internalServerError,
    required TResult Function() userRequestError,
    required TResult Function() jsonParsingError,
  }) {
    return noConnection();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noConnection,
    TResult Function()? internalServerError,
    TResult Function()? userRequestError,
    TResult Function()? jsonParsingError,
    required TResult orElse(),
  }) {
    if (noConnection != null) {
      return noConnection();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoConnection value) noConnection,
    required TResult Function(InternalServerError value) internalServerError,
    required TResult Function(UserRequesrError value) userRequestError,
    required TResult Function(JsonParsingError value) jsonParsingError,
  }) {
    return noConnection(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoConnection value)? noConnection,
    TResult Function(InternalServerError value)? internalServerError,
    TResult Function(UserRequesrError value)? userRequestError,
    TResult Function(JsonParsingError value)? jsonParsingError,
    required TResult orElse(),
  }) {
    if (noConnection != null) {
      return noConnection(this);
    }
    return orElse();
  }
}

abstract class NoConnection implements WeatherFailure {
  const factory NoConnection() = _$NoConnection;
}

/// @nodoc
abstract class $InternalServerErrorCopyWith<$Res> {
  factory $InternalServerErrorCopyWith(
          InternalServerError value, $Res Function(InternalServerError) then) =
      _$InternalServerErrorCopyWithImpl<$Res>;
}

/// @nodoc
class _$InternalServerErrorCopyWithImpl<$Res>
    extends _$WeatherFailureCopyWithImpl<$Res>
    implements $InternalServerErrorCopyWith<$Res> {
  _$InternalServerErrorCopyWithImpl(
      InternalServerError _value, $Res Function(InternalServerError) _then)
      : super(_value, (v) => _then(v as InternalServerError));

  @override
  InternalServerError get _value => super._value as InternalServerError;
}

/// @nodoc

class _$InternalServerError implements InternalServerError {
  const _$InternalServerError();

  @override
  String toString() {
    return 'WeatherFailure.internalServerError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InternalServerError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noConnection,
    required TResult Function() internalServerError,
    required TResult Function() userRequestError,
    required TResult Function() jsonParsingError,
  }) {
    return internalServerError();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noConnection,
    TResult Function()? internalServerError,
    TResult Function()? userRequestError,
    TResult Function()? jsonParsingError,
    required TResult orElse(),
  }) {
    if (internalServerError != null) {
      return internalServerError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoConnection value) noConnection,
    required TResult Function(InternalServerError value) internalServerError,
    required TResult Function(UserRequesrError value) userRequestError,
    required TResult Function(JsonParsingError value) jsonParsingError,
  }) {
    return internalServerError(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoConnection value)? noConnection,
    TResult Function(InternalServerError value)? internalServerError,
    TResult Function(UserRequesrError value)? userRequestError,
    TResult Function(JsonParsingError value)? jsonParsingError,
    required TResult orElse(),
  }) {
    if (internalServerError != null) {
      return internalServerError(this);
    }
    return orElse();
  }
}

abstract class InternalServerError implements WeatherFailure {
  const factory InternalServerError() = _$InternalServerError;
}

/// @nodoc
abstract class $UserRequesrErrorCopyWith<$Res> {
  factory $UserRequesrErrorCopyWith(
          UserRequesrError value, $Res Function(UserRequesrError) then) =
      _$UserRequesrErrorCopyWithImpl<$Res>;
}

/// @nodoc
class _$UserRequesrErrorCopyWithImpl<$Res>
    extends _$WeatherFailureCopyWithImpl<$Res>
    implements $UserRequesrErrorCopyWith<$Res> {
  _$UserRequesrErrorCopyWithImpl(
      UserRequesrError _value, $Res Function(UserRequesrError) _then)
      : super(_value, (v) => _then(v as UserRequesrError));

  @override
  UserRequesrError get _value => super._value as UserRequesrError;
}

/// @nodoc

class _$UserRequesrError implements UserRequesrError {
  const _$UserRequesrError();

  @override
  String toString() {
    return 'WeatherFailure.userRequestError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is UserRequesrError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noConnection,
    required TResult Function() internalServerError,
    required TResult Function() userRequestError,
    required TResult Function() jsonParsingError,
  }) {
    return userRequestError();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noConnection,
    TResult Function()? internalServerError,
    TResult Function()? userRequestError,
    TResult Function()? jsonParsingError,
    required TResult orElse(),
  }) {
    if (userRequestError != null) {
      return userRequestError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoConnection value) noConnection,
    required TResult Function(InternalServerError value) internalServerError,
    required TResult Function(UserRequesrError value) userRequestError,
    required TResult Function(JsonParsingError value) jsonParsingError,
  }) {
    return userRequestError(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoConnection value)? noConnection,
    TResult Function(InternalServerError value)? internalServerError,
    TResult Function(UserRequesrError value)? userRequestError,
    TResult Function(JsonParsingError value)? jsonParsingError,
    required TResult orElse(),
  }) {
    if (userRequestError != null) {
      return userRequestError(this);
    }
    return orElse();
  }
}

abstract class UserRequesrError implements WeatherFailure {
  const factory UserRequesrError() = _$UserRequesrError;
}

/// @nodoc
abstract class $JsonParsingErrorCopyWith<$Res> {
  factory $JsonParsingErrorCopyWith(
          JsonParsingError value, $Res Function(JsonParsingError) then) =
      _$JsonParsingErrorCopyWithImpl<$Res>;
}

/// @nodoc
class _$JsonParsingErrorCopyWithImpl<$Res>
    extends _$WeatherFailureCopyWithImpl<$Res>
    implements $JsonParsingErrorCopyWith<$Res> {
  _$JsonParsingErrorCopyWithImpl(
      JsonParsingError _value, $Res Function(JsonParsingError) _then)
      : super(_value, (v) => _then(v as JsonParsingError));

  @override
  JsonParsingError get _value => super._value as JsonParsingError;
}

/// @nodoc

class _$JsonParsingError implements JsonParsingError {
  const _$JsonParsingError();

  @override
  String toString() {
    return 'WeatherFailure.jsonParsingError()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is JsonParsingError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() noConnection,
    required TResult Function() internalServerError,
    required TResult Function() userRequestError,
    required TResult Function() jsonParsingError,
  }) {
    return jsonParsingError();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? noConnection,
    TResult Function()? internalServerError,
    TResult Function()? userRequestError,
    TResult Function()? jsonParsingError,
    required TResult orElse(),
  }) {
    if (jsonParsingError != null) {
      return jsonParsingError();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NoConnection value) noConnection,
    required TResult Function(InternalServerError value) internalServerError,
    required TResult Function(UserRequesrError value) userRequestError,
    required TResult Function(JsonParsingError value) jsonParsingError,
  }) {
    return jsonParsingError(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NoConnection value)? noConnection,
    TResult Function(InternalServerError value)? internalServerError,
    TResult Function(UserRequesrError value)? userRequestError,
    TResult Function(JsonParsingError value)? jsonParsingError,
    required TResult orElse(),
  }) {
    if (jsonParsingError != null) {
      return jsonParsingError(this);
    }
    return orElse();
  }
}

abstract class JsonParsingError implements WeatherFailure {
  const factory JsonParsingError() = _$JsonParsingError;
}
